# tools for slopes
#

#' slopeGraph
#' 
#' @param mp is the microplate
#' @param wellNr the wellNr you want the analysis on
#' @param nrOfTimePoints the width  default=10
#' 
#' @export
slopeGraph=function(mp,wellNr,nrOfTimePoints=10){
  index=getWellsMeasurementIndex(mp,wellNr)
  time=mp[index,"time"][,1]
  value=mp[index,"value"][,1]
  
  slopes=data.frame(matrix(0, (length(time)-nrOfTimePoints),3) )
  names(slopes)=c("m","b","r^2")
  selection=1:(length(time)-nrOfTimePoints)
  for(i in selection){
    start=i
    stop=i+nrOfTimePoints
    slopes[i,]=getSlope(mp,wellNr,start,stop,logY=T,plot=F)
  }
  # 2 plots in 1 graph
  # http://stackoverflow.com/questions/6142944/how-can-i-plot-with-2-different-y-axes-in-r
  # or: http://robjhyndman.com/hyndsight/r-graph-with-two-y-axes/
  # 
  plot(slopes[[1]],type="l",ylab="slope",ylim = c(min(slopes[[1]]),max(slopes[[1]])))
  abline(h=0)  
  par(new=TRUE)
  plot(slopes[[3]],type="l",col="red",xaxt="n",yaxt="n",xlab="",ylab="",ylim = c(min(slopes[[3]]),max(slopes[[3]])))
  axis(4)
  par(new=TRUE)
  plot(time,log(value), type="l",col="blue",xaxt="n",yaxt="n",xlab="",ylab="")
  mtext("y2",side=4,line=3,col="red")
  legend("topright",col=c("blue","black","red"),lty=1,legend=c("graph","slope","r^2"))
  return(slopes)
}


#' getSlope
#' 
#' returns: c(m,b,r^2)
#' 
#' 
#' @param mp is the microplate
#' @param wellNr the wellNr you want the analysis on
#' @param start ...
#' @param stop ...
#' @param logY use the natural logarithm on the Y axis, default is true
#' @param plot a graph to show you the result default is true
#' 
#' @export
getSlope=function(mp,wellNr,start,stop,logY=TRUE,plot=TRUE){
  index=getWellsMeasurementIndex(mp,wellNr)
  time=mp[index,"time"][,1]
  value=mp[index,"value"][,1]
  
  if(logY){
    value=log(value) # note log=ln in R
  }
  
  selection=start:stop
  n=length(selection)
  
  x=time[selection]
  y=value[selection]
  
  
  # http://stats.stackexchange.com/questions/29525/slope-of-a-line-given-multiple-points
  # the math is described here... no idea how but it works :P
  
  # http://www.clemson.edu/ces/phoenix/tutorials/excel/regression.html
  
  
  xy=x*y 
  # y=mx+b
  m=(n*sum(xy)-sum(x)*sum(y)) / (n*sum(x^2)-sum(x)^2)
  b=(sum(y)-m*sum(x))/n
  r=(n*sum(xy)-sum(x)*sum(y))/sqrt((n*sum(x^2)-sum(x)^2)*(n*sum(y^2)-sum(y)^2))
  #   print(m)
  #   print(b)
  #   print(r^2)
  
  if(plot){
    startPointSlopeX=time[start]
    startPointSlopeY=value[start]
    
    plot(time,value)
    
    lines(time+startPointSlopeX,((time*m)+startPointSlopeY)) #slope
    
    abline(v=time[start])
    abline(v=time[stop])
  }
  
  return(c(m,b,r^2))
}


#' getGrowthRate
#' @rdname getGrowthRate
#' @description
#' uses the grofit package to determine growth rate???
#' currently just returns the grofit results
#' 
#' TODO: what if time is not on measurment level?
#' TODO: add gcID support
#' TODO: what if multiple wavelengths?
#' TODO: log the data?!?!?! or ask user to???
#' TODO: check if my score is actually a score...
#' 
#' default it uses time, value
#' and it separetes it based on wavelength 
#' 
#' 
#' 
#' @param self the MicroPlate object
#' @param wellNrs logical/numerical selection or well numbers - missing is all
#' @param timeColumn column with time, the time point in all selected wells need to be equeal
#' @param valueColumn column with the OD values
#' @param settings parameters passed to the grofit package see \code{\link[grofit]{grofit.control}}:
#' 
#' 
#' @export
#' @import grofit
setGeneric("getGrowthRate", function(self, wellNrs=NULL, timeColumn="time", valueColumn="value", settings=NULL) standardGeneric("getGrowthRate"))
#' @rdname getGrowthRate
setMethod("getGrowthRate", signature(self = "MicroPlate"), function(self, wellNrs=NULL, timeColumn="time", valueColumn="value", settings=NULL){
  # gcFitSpline wants:
  # time    - Numeric vector containing the data for x-axes.
  # data    - Numeric vector giving the growth values belonging to each element of time.
  # gcID    - Vector (of any length) identifying the growth curve data.
  # control - Object of class grofit.control containing a list of options generated by the function grofit.control.#   
  
  
  # maybe just do a gcSplineFit thingy for each well... that way i dont require as much stuff
  if(is.null(settings)){
    print("no settings provided")
    settings=grofit.control(log.y.gc=T,interactive=F)
    #     message("no settings provided using defaults: nboot.gc=100,interactive=F,suppress.messages=T,model.type=c('gompertz')")
    #     settings=grofit.control(nboot.gc=100,interactive=F,suppress.messages=T,model.type=c("gompertz"))
  }
  
  # 
  
  ### check input
  # wellNrs
  if(is.null(wellNrs)) wellNrs=1:self@.data$levelSize[2] # if not specified get it for everything
  if(is.logical(wellNrs)){
    if(length(wellNrs)==self@.data$levelSize[2]){
      wellNrs=(1:self@.data$levelSize[2])[wellNrs]
    }else{
      stop(paste("nr of wells: ",self@.data$levelSize[2] ," your selection: ",length(wellNrs), sep=""))
    }
  }
  # columnSelectors
  #   # todo: maybe remove additional columns... and do other grofit matches
  #   columns=c(timeColumn,valueColumn,experimentIdentifierColumn,additionalInformationColumn,concentrationOfSubstrateColumn)
  #   if(is.character(columns)){
  #     if(!all(self@.data$colnames %in% self@.data$colNames)){
  #       stop("not all columns exist")
  #     }
  #   }
  nrOfWells=length(wellNrs)
  
  results=vector("list", nrOfWells)
  index=0
  
  yieldName="grofit.yield"
  growthRateName="grofit.growthRate"
  lagPhaseTimeName="grofit.lagPhaseTime"
  grofitFitScroreName="grofit.fitScrore"
  
  # reserve space
  if(is.null(self@.data$well[[yieldName]])){
    self@.data$well[[yieldName]]=rep(NA,self@.data$levelSize[2])
  }
  if(is.null(self@.data$well[[growthRateName]])){
    self@.data$well[[growthRateName]]=rep(NA,self@.data$levelSize[2])
  }
  if(is.null(self@.data$well[[lagPhaseTimeName]])){
    self@.data$well[[lagPhaseTimeName]]=rep(NA,self@.data$levelSize[2])
  } 
  if(is.null(self@.data$well[[grofitFitScroreName]])){
    self@.data$well[[grofitFitScroreName]]=rep(NA,self@.data$levelSize[2])
  }
  
  for(i in wellNrs){
    index=index+1
    selection=getWellsMeasurementIndex(self,i)
    time=self[[timeColumn]][selection]
    data=self[[valueColumn]][selection]
    result=gcFitSpline(time=time, data=data, control=settings)
    results[[index]]=result
    
    plot(result)
    title(main = i)
    lambda=result$parameters$lambda
    A=result$parameters$A
    mu=result$parameters$mu
    integral=result$parameters$integral
    plot(result$raw.time,result$raw.data)
    
    
    score=result$spline$crit # is this the score??? need crappier data to test!!
    # $spline$cv.crit might be score... else need to do the model fit for score...
    print(score)
    
    self@.data$well[[yieldName]][i]=A
    self@.data$well[[growthRateName]][i]=mu
    self@.data$well[[lagPhaseTimeName]][i]=lambda
    self@.data$well[[grofitFitScroreName]][i]=score
    #     lines(c(0,60),c(0,1))
    #     print(paste("",lambda,A,mu,integral))
    #     xcor=c(lambda,lambda+5)
    #     xpoint=(integral*A)
    #     print(xpoint)
    #     lines(c(lambda,xpoint),c(0,A))
    #     ycor=c(0,A*5)
    #     print(paste(paste(xcor),paste(ycor)))
    #     print(result$parametersLowess$lambda)
    #     lines(xcor,ycor)
    #     xcor=c(7.13,12.13)
    #     ycor=c(0,3.045)
    #     lines(xcor, ycor)
    #     lines(c(7.13,12.3),c(0,3.045))
    #     lines(c(7.13,12.3),c(0,0.6))
    #     lines(c(0,60),c(0,0.6))
    #     lines(c(lambda,(lambda+50)),c(0,(A*50)))
    #     lines(c(7.13,12.3),c(0,3.045))
    #     lines(x=c(0,50),y=c(0,1))
    
    lines( c(lambda,(lambda+(A/mu))) , c(0,A) )
    
    plot(time,data)
    
    results[index]
  }
  
  updateMetaData(self)
  
  
  
  # todo plot things?
  returnResults=F
  if(returnResults){return(results)}
})


